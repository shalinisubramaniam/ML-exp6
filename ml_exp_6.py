# -*- coding: utf-8 -*-
"""ML - exp 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yvwm9a6dNv9XNIr53up-E9hAn0LoJCWv
"""

# Import necessary libraries
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from scipy.sparse import csr_matrix
from sklearn.neighbors import NearestNeighbors

# Download MovieLens dataset
!wget -q https://files.grouplens.org/datasets/movielens/ml-latest-small.zip
!unzip -q ml-latest-small.zip

# Load datasets
movies = pd.read_csv('ml-latest-small/movies.csv')
ratings = pd.read_csv('ml-latest-small/ratings.csv')

# Preview data
print(movies.head())
print(ratings.head())

# Combine movie genres into a single string
movies['genres'] = movies['genres'].str.replace('|', ' ')
movies['genres'] = movies['genres'].fillna('')

# Use TF-IDF to convert genres into a feature matrix
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(movies['genres'])

# Calculate cosine similarity between movies
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Function to get movie recommendations based on content
def content_based_recommendations(title, cosine_sim=cosine_sim):
    idx = movies[movies['title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:11]  # Top 10 similar movies
    movie_indices = [i[0] for i in sim_scores]
    return movies['title'].iloc[movie_indices]

# Get recommendations for a movie
print("Content-Based Recommendations for 'Toy Story (1995)':")
print(content_based_recommendations('Toy Story (1995)'))

# Function to get collaborative recommendations for a specific user
def collaborative_recommendations(user_id, num_recommendations=10):
    user_idx = user_id - 1  # Adjusting for 0-indexing
    user_vector = sparse_matrix[user_idx].reshape(1, -1)  # Reshape to make it 2D
    distances, indices = model_knn.kneighbors(user_vector, n_neighbors=num_recommendations + 1)

    # Exclude the user itself from similar users
    similar_users = indices.flatten()[1:]
    recommended_movies = []

    # Aggregate recommendations from similar users
    for similar_user in similar_users:
        recommended_movies.extend(user_movie_matrix.columns[user_movie_matrix.iloc[similar_user].values > 0].tolist())

    # Remove duplicates and limit to requested number
    recommended_movies = list(set(recommended_movies))[:num_recommendations]
    return movies[movies['movieId'].isin(recommended_movies)]['title'].tolist()

# Example: Get recommendations for user with user_id 1
print("Collaborative Recommendations for User 1:")
recommendations = collaborative_recommendations(user_id=1)
for movie in recommendations:
    print(movie)